from sqlalchemy.orm import Session
from database.models import ExamDB, QuestionDB, AnswerDB
from models.database_models import ExamCreate, ExamUpdate
from models.question import Question
from typing import List, Optional

class ExamService:
    
    @staticmethod
    def create_exam(db: Session, exam_data: ExamCreate) -> ExamDB:
        """Create a new exam with questions and answers."""
        db_exam = ExamDB(
            name=exam_data.name,
            google_forms_url=exam_data.google_forms_url
        )
        db.add(db_exam)
        db.flush()  # Get the exam ID
        
        # Create questions
        for question_data in exam_data.questions:
            db_question = QuestionDB(
                exam_id=db_exam.id,
                question_text=question_data.question_text,
                question_type=question_data.question_type,
                question_order=question_data.question_order,
                score=question_data.score
            )
            db.add(db_question)
            db.flush()  # Get the question ID
            
            # Create answers
            for answer_data in question_data.answers:
                db_answer = AnswerDB(
                    question_id=db_question.id,
                    answer_text=answer_data.answer_text,
                    is_correct=answer_data.is_correct,
                    answer_order=answer_data.answer_order
                )
                db.add(db_answer)
        
        db.commit()
        db.refresh(db_exam)
        return db_exam
    
    @staticmethod
    def create_exam_from_questions(db: Session, name: str, questions: List[Question], google_forms_url: str = None) -> ExamDB:
        """Create an exam from Question objects (generated by LLM)."""
        db_exam = ExamDB(
            name=name,
            google_forms_url=google_forms_url
        )
        db.add(db_exam)
        db.flush()
        
        for idx, question in enumerate(questions):
            # Map question type
            question_type_map = {1: "multiple_choice", 2: "checkbox", 3: "text"}
            question_type = question_type_map.get(question.type, "multiple_choice")
            
            db_question = QuestionDB(
                exam_id=db_exam.id,
                question_text=question.question,
                question_type=question_type,
                question_order=idx + 1,
                score=question.points
            )
            db.add(db_question)
            db.flush()
            
            # Create answers
            for answer_idx, answer in enumerate(question.answers):
                db_answer = AnswerDB(
                    question_id=db_question.id,
                    answer_text=answer.text,
                    is_correct=answer.is_correct,
                    answer_order=answer_idx + 1
                )
                db.add(db_answer)
        
        db.commit()
        db.refresh(db_exam)
        return db_exam
    
    @staticmethod
    def get_exam_by_id(db: Session, exam_id: int) -> Optional[ExamDB]:
        """Get an exam by ID."""
        return db.query(ExamDB).filter(ExamDB.id == exam_id).first()
    
    @staticmethod
    def get_all_exams(db: Session, skip: int = 0, limit: int = 100) -> List[ExamDB]:
        """Get all exams."""
        return db.query(ExamDB).offset(skip).limit(limit).all()
    
    @staticmethod
    def update_exam(db: Session, exam_id: int, exam_update: ExamUpdate) -> Optional[ExamDB]:
        """Update an exam."""
        db_exam = db.query(ExamDB).filter(ExamDB.id == exam_id).first()
        if not db_exam:
            return None
        
        for field, value in exam_update.model_dump(exclude_unset=True).items():
            setattr(db_exam, field, value)
        
        db.commit()
        db.refresh(db_exam)
        return db_exam
    
    @staticmethod
    def delete_exam(db: Session, exam_id: int) -> bool:
        """Delete an exam."""
        db_exam = db.query(ExamDB).filter(ExamDB.id == exam_id).first()
        if not db_exam:
            return False
        
        db.delete(db_exam)
        db.commit()
        return True